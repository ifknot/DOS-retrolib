/**
 *
 *  @brief     
 *  @details   ~
 *  @author    Jeremy Thornton
 *  @date      14.04.2024
 *  @copyright © Jeremy Thornton, 2024. All right reserved.
 *
 */
#ifndef KBD_INTERUPT_ROUTINES_H
#define KBD_INTERUPT_ROUTINES_H

#include <stdint.h>

#include "../TEST/debug_macros.h"

#include "../DOS/dos_services.h"

#include "kbd_constants.h"

namespace kbd {

	/**
	* @brief If a scan code was generated by a keypress then the value is increased until 255 presses
	* @note the user must either decrease or reset the values(s)
	*/
	volatile uint8_t key_pressed[MAX_SCAN_CODES];

	/**
	* @brief The current moment state of the keypress 1 = pressed 0 = released
	*/
	volatile uint8_t key_states[MAX_SCAN_CODES];
	
	static mem::address_t old_keyboard_ivec;

	namespace xt {

		/**
		* @brief scan code set 1 (Model F) keyboard interupt handler increments key_pressed[scan_code] array every time key pressed 
		* @note Does NOT forward to DOS keyboard handler
		* @details The keyboard controller, by default, will send scan codes in 
		* Scan Code Set 1 (reference the IBM Technical References for a complete list of scan codes).
		* Scan codes in this set come as make/break codes. 
		* The make code is the normal scan code of the key, and the break code is the 
		* make code bitwise "OR"ed with 0x80 (the high bit is set).
		* 
		* On keyboards after the original IBM Model F 83-key, an 0xE0 is prepended to 
		* some keys that didn't exist on the original keyboard.
		*/
		void scan_code_set_1_interrupt_handler();

	}

	void clear_key_pressed_array();

	void install_keyboard_interrupt_handler(void* new_kbd_isr_ptr);

	void restore_keyboard_interupt_handler();

}

#endif